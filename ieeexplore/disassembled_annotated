
binary:     file format binary


Disassembly of section .data:

ds = es wordt geinitialized op cs! == pointer naar '0x00' in programma

00000000 <.data>:
   0:	bf 00 04             	mov    $0x400,%di     offset op 0x400 zetten
   3:	be c0 00             	mov    $0xc0,%si      si = 0xC0
   6:	56                   	push   %si            push 0xC0
   7:	31 c9                	xor    %cx,%cx        cx = 0


READ INPUT, STORE IN 0x400


X  9:	b4 00                	mov    $0x0,%ah       zet upper byte op nul
   b:	cd 16                	int    $0x16          input read -> naar al
   d:	3c 2e                	cmp    $0x2e,%al      compare met char '.'
   f:	aa                   	stos   %al,%es:(%di)  store al in es + di en increment di -> opslaan vanaf 'code + 0x400'
  10:	e0 f7                	loopne 0x9            loop totdat we de . in de input vonden -> decrement cx!!!

  12:	f7 d1                	not    %cx            ones complement -> 
														exact het aantal user input characters (zonder de punt [one's compl 
														= two's compl - 1 = # gelezen chars - 1 = # gelezen digits])
  14:	29 d2                	sub    %dx,%dx        dx = 0
  16:	89 cd                	mov    %cx,%bp        bp = store cx


from 0xC0 onwards: increment mem locations. Stop if one is found that was not zero after increment (i.e. keep changing 0's to 1's until first non-zero is found)
gegarandeerd dat dit stopt bij 0x400 want daar zit de user data!

X 18:	5b                   	pop    %bx            bx = 0xC0
  19:	53                   	push   %bx            push 0xC0
X 1a:	fe 07                	incb   (%bx)          
  1c:	75 03                	jne/jnz    0x21           
  1e:	43                   	inc    %bx            
  1f:	eb f9                	jmp    0x1a           start bij (0xC0) en 
													  increment + schuif op naar volgende geheugenplek; stop indien je door het 
													  incrementen uitkomt op iets dat niet nul is
													  -> bx wijst dan naar dat niet-nul geheugen (maar niet meer gebruikt)

maak 0x200 tot en met 0x3FF gelijk aan nul

  21:	bf 00 02             	mov    $0x200,%di     di = 0x200
  24:	89 f9                	mov    %di,%cx        cx = 0x200
  26:	89 f8                	mov    %di,%ax        ax = 0x200
  28:	f3 aa                	rep stos %al,%es:(%di) maak 0x200 tot 0x400 (non inclusive) gelijk aan nul in geheugen
  2a:	89 fe                	mov    %di,%si        si = 0x400 -> want incremented!!; di = 0x400 ook

increment elke 0x2<NN> met <NN> user input byte

X 2c:	ac                   	lods   %ds:(%si),%al  al = (code + si) en si++
  2d:	89 c3                	mov    %ax,%bx        bx = 0x200 + ingelezen byte
  2f:	fe 07                	incb   (%bx)          (bx)++
  31:	80 fb 2e             	cmp    $0x2e,%bl      vergelijk ingelezen byte (bl = al) met '.'
  34:	75 f6                	jne    0x2c           als niet gelijk: blijf loopen

  36:	fe 0f                	decb   (%bx)          als gelijk -> undo de laatste increment
  38:	5e                   	pop    %si            si = 0xC0
  39:	56                   	push   %si            push 0xC0
  3a:	89 e9                	mov    %bp,%cx        cx = stored bp = aantal digits ingelezen


decrement elke 0x2<NN> met <NN> de bytes vanaf 0xC0
indien een van die 0x2<NN> stuff dan negatief wordt -> spring opnieuw naar 0x18
inden voor elke aantal-digits niets negatief werd -> continue

X 3c:	ac                   	lods   %ds:(%si),%al  al = (si) EN si++!! (si oorspronkelijk 0xC0)
  3d:	89 c3                	mov    %ax,%bx        bx = 0x200 + net ingelezen ding
  3f:	fe 0f                	decb   (%bx)          (bx)--
  41:	7c d5                	jl     0x18           indien (bx) nu negatief wordt (was oorsprongkelijk dus nul) -> spring naar 0x18
  43:	e2 f7                	loop   0x3c           cx-- en ga naar 0x3c als cx nu niet nul is geworden (i.e. doe dit aantal ingelezen bytes keer)

increment result
check of string vanaf di gelijk is aan die vanaf si; zoniet: terug naar 0x18 -> maar hier zijn we dus al zeker van hoe het geheugen vanaf 0xC0 er uitziet (?)

  45:	42                   	inc    %dx            dx++
  46:	5e                   	pop    %si            si = 0xC0
  47:	56                   	push   %si            push 0xC0
  48:	89 e9                	mov    %bp,%cx        cx = stored bp
  4a:	f3 a6                	repz cmpsb %es:(%di),%ds:(%si) zolang (di++) == (si++), decrement cx (of stop ook als cx == 0)
  																	di bleef 0x400, si is 0xC0
  4c:	75 ca                	jne    0x18           indien cx niet nul was, terug naar 0x18

  De bytes vanaf 0xC0 zijn dezelfde als de user input vanaf 0x400! (tot aan de '.', not included)

  4e:	5d                   	pop    %bp            bp = 0xC0

  										PRINT AX in decimaal

  4f:	92                   	xchg   %ax,%dx        ax <-> dx;   belangrijkste: ax = dx
  50:	d4 0a                	aam    $0xa           ah = al/10, rest in al
  52:	e8 00 00             	call   0x55           print beide nibbles als decimaal getal (leading 0 als < 10)
  55:	86 c4                	xchg   %al,%ah
  57:	04 30                	add    $0x30,%al
  59:	cd 29                	int    $0x29
  5b:	c3                   	ret    
